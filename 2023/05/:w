#[derive(Debug, Clone, PartialEq)]
#[repr(u32)]
enum Category {
    Seed,
    Soil,
    Fertilizer,
    Water,
    Light,
    Temperature,
    Humidity,
    Location,
}

impl From<u32> for Category {
    fn from(source: u32) -> Self {
        match source {
            0 => Self::Seed,
            1 => Self::Soil,
            2 => Self::Fertilizer,
            3 => Self::Water,
            4 => Self::Light,
            5 => Self::Temperature,
            6 => Self::Humidity,
            7 => Self::Location,
            _ => panic!("Unexpected number from Category"),
        }
    }
}

#[derive(Debug, Clone)]
struct Map {
    source_cat: Category,
    dest_cat: Category,
    maps: Vec<(u32, u32, u32)>,
}

fn main() {
    let input = std::fs::read_to_string(concat!(env!("CARGO_MANIFEST_DIR"), "/ex.txt")).unwrap();
    let mut lines = input.lines();

    let mut seeds: Vec<u32> = lines
        .next()
        .unwrap()
        .split(": ")
        .last()
        .unwrap()
        .split(" ")
        .map(|s| s.parse::<u32>().unwrap())
        .collect();

    let mut maps: Vec<Map> = Vec::new();

    let mut cat_counter = 0;

    let mut current_map = Map {
        source_cat: Category::Seed,
        dest_cat: Category::Seed,
        maps: Vec::new(),
    };

    let _ = lines.next();

    for line in lines {
        if line == "" {
            maps.push(current_map.clone());
            current_map.maps.drain(..);
            continue;
        } else if line.contains(':') {
            cat_counter += 1;

            current_map.source_cat = (cat_counter - 1).into();
            current_map.dest_cat = cat_counter.into();

            continue;
        }

        let maps = line
            .split(' ')
            .map(|n| n.parse::<u32>().unwrap())
            .collect::<Vec<u32>>();
        current_map.maps.push((maps[0], maps[1], maps[2]));
    }

    maps.push(current_map.clone());

    for i in 0..7 {
        println!("{seeds:?}");
        let source: Category = i.into();
        let dest: Category = (i + 1).into();

        let map = maps
            .iter()
            .find(|m| m.source_cat == source && m.dest_cat == dest)
            .unwrap();

        println!("{:?}", map.maps)
        for mut seed in &mut seeds {
            for map in &map.maps {
                if *seed >= map.1 && *seed < map.1 + map.2 {
                    *seed = map.0 + (*seed - map.1);
                }
            }
        }
    }

    println!("{seeds:?}");
}
